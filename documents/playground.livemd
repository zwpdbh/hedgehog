# Playground

## Introduction

Playground for testing hedgehog project using attached node remotely.

Make sure

* the `@stream_endpoint` is set to `"wss://stream.binance.us:9443/ws/"`
  (US market and EU market's endpoint is different).
* config for `:binance`, endpoint is `https://api.binance.us`.
* set VPN address to EU, such as UK.

<!-- livebook:{"branch_parent_index":0} -->

## Chatper05

For [Chapter05](https://book.elixircryptobot.com/enable-parallel-trading-on-multiple-symbols.html).

Visulaize the supervision tree we just start the project.

```elixir
Kino.Process.render_sup_tree(Naive.Supervisor)
```

At this point:

* `Naive.Supervisor` is `Naive` application level supervisor.Its job is to start a dynamic supervisor: `Naive.DynamicSymbolSupervisor`.
* `Naive.DynamicSymbolSupervisor` will start and supervise some process.

<!-- livebook:{"break_markdown":true} -->

Let's start to trade on some symbol

```elixir
Naive.start_trading("ethusdt")
Naive.start_trading("xrpusdt")
```

Let's see the current supervision tree after start a children from `Naive.DynamicSymbolSupervisor`.

```elixir
DynamicSupervisor.which_children(Naive.DynamicSymbolSupervisor)
|> Enum.each(fn {_, pid, _, _} = _each -> Process.info(pid) |> IO.inspect() end)
```

```elixir
Kino.Process.render_sup_tree(Naive.Supervisor)
```

In general,

* From application level's root supervisor, we start a `DynamicSupervisor` -- `Naive.DynamicSymbolSupervisor`.

* `Naive.DynamicSymbolSupervisor` start children for each trading symbol.

  * Each children of `Naive.DynamicSymbolSupervisor` is also a supervisor.

  * For example, for trading symbol: "ethusdt", it will start a process: `Naive.SymbolSupervisor-ETHUSDT`.

  * This supervisor is started as

    * The result is invoke the `Naive.SymbolSupervisor.start_link/1` with `ETHUSDT` as the parameter.
    * Inside `start_link`, a named supervisor is started: `Supervisor.start_link(__MODULE__, symbol, name: :"#{__MODULE__}-#{symbol}")`.

    ```elixir
    DynamicSupervisor.start_child(
      Naive.DynamicSymbolSupervisor,
      {Naive.SymbolSupervisor, symbol}
    )
    ```

* `Naive.SymbolSupervisor` then use `Supervisor` to start following pair for each symbol.

  * `Naive.Leader` -- this is a `GenServer`
  * `Naive.DynamicTraderSupervisor` -- this is a `DynamicSupervisor`

<!-- livebook:{"branch_parent_index":0} -->

## Chapter05 (optional)

### Kill temrinate a child of a supervisor

After start, the terminal shows errors like:

```txt
2023-08-02 15:20:02.361 [error] GenServer :"Elixir.Naive.Leader-XRPUSDT" terminating
** (BadMapError) expected a map, got: {:http_error, %HTTPoison.Error{reason: :timeout, id: nil}}
    (elixir 1.14.3) lib/map.ex:534: Map.get({:http_error, %HTTPoison.Error{reason: :timeout, id: nil}}, :symbols, nil)
    (naive 0.1.0) lib/naive/leader.ex:123: Naive.Leader.fetch_tick_size/1
    (naive 0.1.0) lib/naive/leader.ex:109: Naive.Leader.fetch_symbol_settings/1
    (naive 0.1.0) lib/naive/leader.ex:33: Naive.Leader.handle_continue/2
    (stdlib 4.3) gen_server.erl:1123: :gen_server.try_dispatch/4
    (stdlib 4.3) gen_server.erl:865: :gen_server.loop/7
    (stdlib 4.3) proc_lib.erl:240: :proc_lib.init_p_do_apply/3
Last message: {:continue, :start_trader}
State: %{symbol: "XRPUSDT"}
```

<!-- livebook:{"break_markdown":true} -->

Is there a way to terminate just `Naive.SymbolSupervisor-XRPUSDT`? This is started by `Naive.DynamicSymbolSupervisor`. \
So, the questions is how to terminate a certain child of a dynamic supervisor?

```elixir
DynamicSupervisor.terminate_child(
  Naive.DynamicSymbolSupervisor,
  Process.whereis(:"Elixir.Naive.SymbolSupervisor-ETHUSDT")
)
```

Notice: The name of the process we want to find is `:"Elixir.Naive.SymbolSupervisor-ETHUSDT"` instead of `:"Naive.SymbolSupervisor-ETHUSDT"`

<!-- livebook:{"break_markdown":true} -->

### Find a pid from a registered name

Another thing to notice is when we use `Process.whereis/1`, we need to run this on the node which it is checking.

```elixir
:rpc.call(:myapp@localhost, Process, :whereis, [Naive.Supervisor])
```

Fortunately, when we are using Livebook with attached node, we execute code directly on the remote note. \
So, simple `Process.whereis` is good enough.

```elixir
Process.whereis(Naive.Supervisor)
```

Notice if the process is registered as `:"xxx.yyy.zzz"`, we need to use it as `:"xxx.yyy.zzz"`. \
Otherwise, we need to use it as `xxx.yyy.zzz`.

<!-- livebook:{"branch_parent_index":0} -->

## Chapter06

For [chapter06](https://book.elixircryptobot.com/introduce-a-buy_down_interval-to-make-a-single-trader-more-profitable.html#introduce-a-buy_down_interval-to-make-a-single-trader-more-profitable)

<!-- livebook:{"break_markdown":true} -->

### Review

* From Chapter05, we could see for trading one symbol. We could start multiple traders.
* From Chapter04, we build a event system with `PubSub` at its center.
  * A streamer use `PubSub` to broadcast to a corresponding channel.
  * Traders subscribing to a symbol's topic from `PubSub`.

<!-- livebook:{"break_markdown":true} -->

### A simple problem we want to solve

* Occational, traderA's sell order could be picked up by traderB's buy order.
* Therefore, we waste extra transaction fee for nothing (two transaction fee without any profit).

<!-- livebook:{"break_markdown":true} -->

### Solution

Introduce a `buy_down_interval` which will work as follow:

* Instead of placing a new buy order at the current price, we place a buy order slightly lower than the current price. That is the interval between current price and the price we will buy.
* The interval should never be smaller than double the fee we pay for transaction.

<!-- livebook:{"break_markdown":true} -->

### Update code

* Update`Naive.Trader` 
  * Include `buy_down_interval` into the trader's state.
  * Calculate buy price based on:
    * current event price.
    * `buy_down_interval`
    * a symbol's `tick_size`
    * all compute using decimal precision.
* Update `Naive.Leader` since it is managing the trader's state.

<!-- livebook:{"break_markdown":true} -->

### Test

* Change `config/config.exs` to make `Logger` use level `:debug` instead of `info`.

```elixir
"XRPUSDT"
|> String.upcase()
|> Streamer.start_streaming()
```

```elixir
"XRPUSDT"
|> String.upcase()
|> Naive.start_trading()
```

```elixir
Kino.Process.render_sup_tree(Naive.Supervisor)
```

```elixir
# After mix compiel, we could load the updated module
:code.load_file(Naive.Leader)
```

```elixir
# If something goes wrong, we could stop the "Naive.SymbolSupervisor-xxx"
DynamicSupervisor.terminate_child(
  Naive.DynamicSymbolSupervisor,
  Process.whereis(:"Elixir.Naive.SymbolSupervisor-XRPUSDT")
)
```

<!-- livebook:{"branch_parent_index":0} -->

## Chapter07

### Review so far

(For [Chapter07](https://book.elixircryptobot.com/introduce-a-trader-budget-and-calculating-the-quantity.html))

* we have one trader for one symbol (defined in `chunk` from `fetch_symbol_settings/1` in `Naive.Leader`).
* we have 100 quantity to trade for that only one trader.

<!-- livebook:{"break_markdown":true} -->

### Objectives

A trader will be assigned with budget and its quantity will be calculated from it.

* budget, the actual amount of money.
* quantity, the number of share we could trade for a symbol
* So, quantity is computed from 
  * budget
  * symbol's current price
  * step_size, where `step_size` means "the intervals that a quantity/iceberg quantity can be increased or decreased by"
    * Compare this with `tick_size`, the minimum change in the unit price.

<!-- livebook:{"break_markdown":true} -->

### Update code

* `Naive.Leader`
  * For each symbol, we need to add `step_size`.
  * Append `budget` and `step_size` into trader's state
* `Naive.Trader`
  * In trader, we use `step_size` and `budget` to get the quantity.

<!-- livebook:{"branch_parent_index":0} -->

## Chapter08

For [Chapter08](https://book.elixircryptobot.com/add-support-for-multiple-transactions-per-order.html)

### Review so far

#### The potential data race problem

Sometimes our order will be filled by two or more transactions:
The easiest and the safest way to check has this event filled our order fully is to fetch our order again from Binance at the moment when trade event filling our order arrives.

The problem with this approach is that sometimes we will run into a race condition:

The easiest and the safest way to check has this event filled our order fully is to fetch our order again from Binance at the moment when trade event filling our order arrives.

The problem with this approach is that sometimes we will run into a race condition:

#### Solution

What we need to do is to update the status of the buy order after the first fetch(if itâ€™s filled) so when the second trade event arrives we will ignore it(this will require an additional callback).

<!-- livebook:{"break_markdown":true} -->

### Modifications

* Modify the callback which monitors incoming trade events for ones filling its buy order and then places sell order.
  * modify the callback which monitors incoming trade events for ones filling its buy order and then places sell order.

<!-- livebook:{"branch_parent_index":0} -->

## Chapter09

From [chapter09](https://book.elixircryptobot.com/run-multiple-traders-in-parallel.html)

The goal is to solve the following problem:\
Currently we start multiple traders at the same time when we start to trade for one symbol, what we want to achieve is start one trader, then start the second one when the price goes down for some degree, call it `rebuy_interval`.  If the price continue goes down, we start the third one, so on and so forth.

By doing this, we could achieve a lot more profit as the price goes in some "V" shape.

The code we need to change include:

<!-- livebook:{"break_markdown":true} -->

### Trader

* add `rebuy_interval` and `rebuy_noticed` in trader state.

  The `rebuy_noticed` is included because the rebuy signal must be sent from some trader. Because some trader receive the trading events and decide if the price has goes down enough since its buy order filled.

* add `id` to distinguish each trader from each other.

* Rebuy logic should be placed almost as the last callback just before the one that ignores all events.

  * Sent to `Leader` using `GenServer.call` with protocol `{:rebuy_triggered, trader_state}`.

<!-- livebook:{"break_markdown":true} -->

### Leader

* Modify how we start traders, now we still start a list of traders but the number of trader is one.
* Handle call event sent from some trader: 
  * we need the trader's PID to be able to find it details inside the list of traders
  * we need settings to confirm the number of chunks to be able to limit the maximum number of parallel traders.

<!-- livebook:{"branch_parent_index":0} -->

## Chapter10

From [chapter10](https://book.elixircryptobot.com/fine-tune-trading-strategy-per-symbol.html)

So far each symbol's setting is hard coded into the elixir code. We want to use different settings for different symbols.

We introduce data persistense now and will save settings into Postgres database.

<!-- livebook:{"break_markdown":true} -->

### Add Postgres to project as docker-compose services

Create a `docker-compose.yml` file and fill it with

```yaml
# /docker-compose.yml
version: "3.2"
services:
  db:
    image: postgres:latest
    restart: always
    environment:
      POSTGRES_PASSWORD: "postgres"
    ports:
      - 5432:5432
    volumes:
      - ../postgres-data:/var/lib/postgresql/data
```

start the services by:

```sh
docker-compose up -d
Creating network "hedgehog_default" with the default driver
Creating hedgehog_db_1 ... done
```

<!-- livebook:{"break_markdown":true} -->

### Setup `ecto` inside `naive` app

<!-- livebook:{"break_markdown":true} -->

#### Prepare dependencies

First, add dependencies to `naive` app

* `ecto_sql`, [provides functionality for working with SQL databases in Ecto](https://hexdocs.pm/ecto_sql/Ecto.Adapters.SQL.html)
  * One of its supported adapter is `Ecto.Adapters.Postgres` which uses `Postgrex` for communicating to the database.
* `ecto_enum`, [used whenever you want to keep atom values in a field](https://hexdocs.pm/ecto/Ecto.Enum.html)
* `postgrex`, PostgreSQL driver for Elixir.

<!-- livebook:{"break_markdown":true} -->

#### Add ecto repo to application

After modify `/apps/naive/mix.exs` and run `mix deps.get`, we need to add the ecto repo to the application.

```sh
$ cd apps/naive
$ mix ecto.gen.repo -r Naive.Repo
* creating lib/naive
* creating lib/naive/repo.ex
* updating ../../config/config.ex
```

<!-- livebook:{"break_markdown":true} -->

#### Config ecto repo in application

* Add `Naive.Repo` into application's supervision tree.
* Update `/config/config.exs` to speicfy the ecto repo and how to connect to it.

<!-- livebook:{"force_markdown":true} -->

```elixir
# Specify the ecto repos used for :naive application.  
config :naive,
  ecto_repos: [Naive.Repo]

# Specify how to connect to ecto repo "Naive.Repo" for :naive application.
config :naive, Naive.Repo,
  database: "naive_repo",
  username: "postgres",
  password: "postgres",
  hostname: "localhost"
```

`Naive.Repo` will be the name we use across Elixir application to represent database `naive_repo`.

<!-- livebook:{"break_markdown":true} -->

#### Setup supervision tree for DB connection.

The last step is to create database connection when application is started, we need to add `Naive.Repo` into the list of `Naive.Application`.

<!-- livebook:{"force_markdown":true} -->

```elixir
# /apps/naive/lib/naive/application.ex
def start(_type, _args) do
  children = [
    {Naive.Repo, []}, # <= added line
    {
      DynamicSupervisor,
      strategy: :one_for_one, name: Naive.DynamicSymbolSupervisor
    }
  ]
  #...
```

Notice the order children matters.

<!-- livebook:{"break_markdown":true} -->

### Create and migrate the DB

All the above steps just defines the DB and how to talk to it in Elixir application. 
In this part, we will

* create the database
* create the table by migration
* create schema to the table

<!-- livebook:{"break_markdown":true} -->

#### create database

```sh
mix ecto.create -r Naive.Repo
The database for Naive.Repo has been created
```

<!-- livebook:{"break_markdown":true} -->

#### create table migration

Tables are created by

* define migration
* run migration

```
zw@zwpdbh:~/code/elixir_programming/hedgehog$ cd apps/naive/
zw@zwpdbh:~/code/elixir_programming/hedgehog/apps/naive$ mix ecto.gen.migration create_settings
* creating priv/repo/migrations
* creating priv/repo/migrations/20230817072601_create_settings.exs
```

**Notice** we need to switch to `naive` application's directory to run `ecto.gen.migration`.

<!-- livebook:{"break_markdown":true} -->

By editing the generated `priv/repo/migrations/xxx.exs` migration file, we could create or update database table.

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Naive.Repo.Migrations.CreateSettings do
  use Ecto.Migration

  alias Naive.Schema.TradingStatusEnum

  def change do
     TradingStatusEnum.create_type()

     create table(:settings, primary_key: false) do
      add(:id, :uuid, primary_key: true)
      add(:symbol, :text, null: false)
      add(:chunks, :integer, null: false)
      add(:budget, :decimal, null: false)
      add(:buy_down_interval, :decimal, null: false)
      add(:profit_interval, :decimal, null: false)
      add(:rebuy_interval, :decimal, null: false)
      add(:status, TradingStatusEnum.type(), default: "off", null: false)

      timestamps()
    end

    create(unique_index(:settings, [:symbol]))
  end
end
```

**Notice**

* Use `uuid` for `id`
* Use `timestamps`
* Create unique index for `symbol` column.
* Use enum type for `status` column.

The `Naive.Schema.TradingStatusEnum` module is created as

<!-- livebook:{"force_markdown":true} -->

```elixir
import EctoEnum
defenum(Naive.Schema.TradingStatusEnum, :trading_status, [:on, :off])
```

After this migration is defined, execute the migration by

```sh
zw@zwpdbh:~/code/elixir_programming/hedgehog/apps/naive$ mix ecto.migrate
Compiling 1 file (.ex)
Generated naive app

15:50:57.081 [info] == Running 20230817072601 Naive.Repo.Migrations.CreateSettings.change/0 forward

15:50:57.086 [info] execute "CREATE TYPE public.trading_status AS ENUM ('on', 'off')"

15:50:57.087 [info] create table settings

15:50:57.095 [info] create index settings_symbol_index

15:50:57.099 [info] == Migrated 20230817072601 in 0.0s
```

<!-- livebook:{"break_markdown":true} -->

#### Create schema for table

The last step to use data from database table is to define the scehma for it.\
Create the `/apps/naive/lib/naive/schema/settings.ex`

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Naive.Schema.Settings do
  use Ecto.Schema

  alias Naive.Schema.TradingStatusEnum

  @primary_key {:id, :binary_id, autogenerate: true}

  schema "settings" do
    field(:symbol, :string)
    field(:chunks, :integer)
    field(:budget, :decimal)
    field(:buy_down_interval, :decimal)
    field(:profit_interval, :decimal)
    field(:rebuy_interval, :decimal)
    field(:status, TradingStatusEnum)

    timestamps()
  end
end
```

An "Ecto schema" refers to a module that defines the structure of a database table and its associated fields.\
It defines how we interact with data of a table in Elixir code.
Such as how to query or update records of table in database.

<!-- livebook:{"break_markdown":true} -->

#### Seed symbol's settings

After we have created the DB, created table by migration and defined our schema. It is time to generate some settings for each symbol.

* Define default settings inside `config/config.exs`
* Create a seed script that will fetch all pairs from Binance and insert a new config row inside DB for each symbol.

<!-- livebook:{"break_markdown":true} -->

Place the following setting into `config/config.exs` for `config :naive`:

<!-- livebook:{"force_markdown":true} -->

```elixir
trading: %{
    defaults: %{
      chunks: 5,
      budget: 1000,
      buy_down_interval: "0.0001",
      profit_interval: "-0.0012",
      rebuy_interval: "0.001"
    }
  }
```

<!-- livebook:{"break_markdown":true} -->

The seed script for `naive` app is `apps/naive/priv/seed_settings.exs`. Run it using `mix` within the application directory.

```
$ cd apps/naive/
$ mix run priv/seed_settings.exs 
2023-08-23 17:04:18.306 [info] Fetching exchange info from Binance to create trading settings
2023-08-23 17:04:19.979 [info] Inserting default settings for symbols
...
2023-08-23 17:04:20.032 [info] Inserted settings for 536 symbols
```

<!-- livebook:{"break_markdown":true} -->

### Update `Naive.Leader` to fetch settings

We need to mofiy the `fetch_symbol_settings/1` to fetch settings from DB instead of the hardcoded map.

<!-- livebook:{"branch_parent_index":0} -->

## Tmp

```elixir
defmodule Project.Worker do
  use GenServer

  def start_link(_ignore \\ nil) do
    GenServer.start_link(__MODULE__, nil, [])
  end

  def init(_arg) do
    {:ok, []}
  end

  def handle_call("Hi!", _from, state) do
    {:reply, "Hola!", state}
  end
end
```

```elixir
{:ok, pid} = Project.Worker.start_link()
```

```elixir
Process.register(pid, :"Project.Worker")
```

```elixir
Process.whereis(Project.Worker)
```

```elixir
Process.whereis(String.to_atom("Project.Worker"))
```
